目      录
译者序
前言
第一部分   程序员必读
第1章   对程序错误的处理	1
1.1   定义自己的错误代码	4
1.2   ErrorShow示例应用程序	5
第2章   Unicode	11
2.1   字符集	11
2.1.1   单字节与双字节字符集	11
2.1.2   Unicode：宽字节字符集	12
2.2   为什么使用Unicode	13
2.3   Windows 2000与Unicode	13
2.4   Windows 98与Unicode	13
2.5   Windows CE与Unicode	14
2.6   需要注意的问题	14
2.7   对COM的简单说明	14
2.8   如何编写Unicode源代码	15
2.8.1   C运行期库对Unicode的支持	15
2.8.2   Windows定义的Unicode数据类型	17
2.8.3   Windows中的Unicode函数和ANSI
           函数	17
2.8.4   Windows字符串函数	19
2.9   成为符合ANSI和Unicode的应用程序	19
2.9.1   Windows字符串函数	19
2.9.2   资源	22
2.9.3   确定文本是ANSI文本还是Unicode
          文本	22
2.9.4   在Unicode与ANSI之间转换字符串	23
第3章   内核对象	27
3.1   什么是内核对象	27
3.1.1   内核对象的使用计数	27
3.1.2   安全性	28
3.2   进程的内核对象句柄表	30
3.2.1   创建内核对象	30
3.2.2   关闭内核对象	32
3.3   跨越进程边界共享内核对象	32
3.3.1   对象句柄的继承性	32
3.3.2   改变句柄的标志	35
3.3.3   命名对象	36
3.3.4   终端服务器的名字空间	39
3.3.5   复制对象句柄	39
第二部分   编程的具体方法
第4章   进程	45
4.1   编写第一个Windows应用程序	46
4.1.1   进程的实例句柄	49
4.1.2   进程的前一个实例句柄	50
4.1.3   进程的命令行	50
4.1.4   进程的环境变量	51
4.1.5   进程的亲缘性	54
4.1.6   进程的错误模式	54
4.1.7   进程的当前驱动器和目录	54
4.1.8   进程的当前目录	55
4.1.9   系统版本	56
4.2   CreateProcess函数	58
4.2.1   pszApplicationName和
           pszCommandLine	59
4.2.2   psa Process、psa Thread和
           binherit Handles	60
4.2.3   fdwCreate	62
4.2.4   pvEnvironment	64
4.2.5   pszCurDir	64
4.2.6   psiStartInfo	64
4.2.7   ppiProcInfo	67
4.3   终止进程的运行	69
4.3.1   主线程的进入点函数返回	69
4.3.2   ExitProcess函数	69
4.3.3   TerminateProcess函数	70
4.3.4   进程终止运行时出现的情况	71
4.4   子进程	72
4.5   枚举系统中运行的进程 	73
第5章   作业	91
5.1   对作业进程的限制	93
5.2   将进程放入作业	99
5.3   终止作业中所有进程的运行	99
5.4   查询作业统计信息	100
5.5   作业通知信息	103
5.6   JobLab示例应用程序	104
第6章   线程的基础知识	121
6.1   何时创建线程	121
6.2   何时不能创建线程	122
6.3   编写第一个线程函数	123
6.4   CreateThread函数	124
6.4.1   psa	124
6.4.2   cbStack	124
6.4.3   pfnStartAddr和pvParam	125
6.4.4   fdwCreate	126
6.4.5   pdwThreadID	126
6.5   终止线程的运行	127
6.5.1   线程函数返回	127
6.5.2   ExitThread函数	127
6.5.3    TerminateThread函数	127
6.5.4    在进程终止运行时撤消线程	128
6.5.5   线程终止运行时发生的操作	128
6.6   线程的一些性质	129
6.7   C/C++运行期库的考虑	131
6.7.1   Oops―错误地调用了Create Thread	138
6.7.2   不应该调用的C/C++运行期库函数	138
6.8   对自己的ID概念应该有所了解	139
第7章   线程的调度、优先级和亲缘性	142
7.1   暂停和恢复线程的运行	143
7.2   暂停和恢复进程的运行	144
7.3   睡眠方式	145
7.4   转换到另一个线程	145
7.5   线程的运行时间	146
7.6   运用环境结构	148
7.7   线程的优先级	152
7.8   对优先级的抽象说明	153
7.9   程序的优先级	156
7.9.1   动态提高线程的优先级等级	158
7.9.2   为前台进程调整调度程序	159
7.9.3   Scheduling Lab示例应用程序	160
7.10   亲缘性	167
第8章   用户方式中线程的同步	172
8.1   原子访问：互锁的函数家族	172
8.2   高速缓存行	177
8.3   高级线程同步	178
8.4   关键代码段	180
8.4.1   关键代码段准确的描述	182
8.4.2   关键代码段与循环锁	185
8.4.3   关键代码段与错误处理	185
8.4.4   非常有用的提示和技巧	186
第9章   线程与内核对象的同步	190
9.1   等待函数	191
9.2   成功等待的副作用	194
9.3   事件内核对象	195
9.4   等待定时器内核对象	204
9.4.1   让等待定时器给APC项排队	207
9.4.2   定时器的松散特性	209
9.5   信标内核对象	210
9.6   互斥对象内核对象	211
9.6.1   释放问题	213
9.6.2   互斥对象与关键代码段的比较	214
9.6.3   Queue示例应用程序	214
9.7   线程同步对象速查表	223
9.8   其他的线程同步函数	224
9.8.1   异步设备I/O	224
9.8.2   WaitForInputIdle	224
9.8.3   MsgWaitForMultipleObjects (Ex)	225
9.8.4   WaitForDebugEvent	225
9.8.5   SingleObjectAndWait	226
第10章   线程同步工具包	228
10.1   实现关键代码段：Optex	228
10.2   创建线程安全的数据类型和反信标	239
10.3   单个写入程序/多个阅读程序的保护	251
10.4   实现一个WaitForMultipleExpressions
       函数	259
第11章   线程池的使用	274
11.1   方案1：异步调用函数	275
11.2   方案2：按规定的时间间隔调用函数	277
11.3   方案3：当单个内核对象变为已通知状态
           时调用函数	283
11.4   方案4：当异步I/O请求完成运行时调用
          函数	285
第12章   纤程	287
12.1   纤程的操作	287
12.2   Counter示例应用程序	289
第三部分   内 存 管 理
第13章   Windows的内存结构	299
13.1   进程的虚拟地址空间	299
13.2   虚拟地址空间如何分区	300
13.2.1   NuLL 指针分配的分区―适用于
             Windows 2000和Windows 98	300
13.2.2   MS-DOS/16位Windows 应用程序兼容
             分区―仅适用于Windows 98	301
13.2.3   用户方式分区―适用于Windows 2000
             和Windows 98	301
13.2.4   64 KB禁止进入的分区―仅适用
             于Windows 2000	302
13.2.5   共享的MMF分区―仅适用于
             Windows 98	303
13.2.6   内核方式分区―适用于Windows 
             2000和Windows 98	303
13.3   地址空间中的区域	303
13.4    提交地址空间区域中的物理存储器	304
13.5   物理存储器与页文件	304
13.6   保护属性	307
13.6.1   Copy-On-Write 访问	308
13.6.2   特殊的访问保护属性的标志	309
13.7   综合使用所有的元素	309
13.7.1   区域的内部情况	312
13.7.2   与Windows 98地址空间的差别	315
13.8   数据对齐的重要性	319
第14章   虚拟内存	323
14.1   系统信息	323
14.2   虚拟内存的状态	330
14.3   确定地址空间的状态	336
14.3.1   VMQuery函数	337
14.3.2   虚拟内存表示例应用程序	343
第15章   在应用程序中使用虚拟内存	354
15.1   在地址空间中保留一个区域	354
15.2   在保留区域中的提交存储器	355
15.3   同时进行区域的保留和内存的提交	356
15.4   何时提交物理存储器	357
15.5   回收虚拟内存和释放地址空间区域	358
15.5.1   何时回收物理存储器	359
15.5.2   虚拟内存分配的示例应用程序	360
15.6   改变保护属性	368
15.7   清除物理存储器的内容	369
15.8      地址窗口扩展―适用于
             Windows 2000	372
第16章   线程的堆栈	385
16.1   Windows 98下的线程堆栈	387
16.2   C/C++运行期库的堆栈检查函数	389
16.3   Summation示例应用程序	390
第17章   内存映射文件	397
17.1   内存映射的可执行文件和DLL
           文件	397
17.1.1   可执行文件或DLL的多个实例
             不能共享静态数据	398
17.1.2   在可执行文件或DLL的多个实
             例之间共享静态数据	400
17.1.3   AppInst示例应用程序	404
17.2   内存映射数据文件	409
17.2.1   方法 1：一个文件，一个缓存	409
17.2.2   方法 2：两个文件，一个缓存	409
17.2.3   方法 3：一个文件，两个缓存	410
17.2.4   方法 4：一个文件，零缓存	410
17.3   使用内存映射文件	410
17.3.1   步骤 1：创建或打开文件内核
             对象	411
17.3.2   步骤 2：创建一个文件映射内核
             对象	412
17.3.3   步骤 3：将文件数据映射到进程
               的地址空间	414
17.3.4   步骤4：从进程的地址空间中撤消
             文件数据的映像	416
17.3.5   步骤 5和步骤 6：关闭文件映射对象
             和文件对象	417
17.3.6   文件倒序示例应用程序	418
17.4   使用内存映射文件来处理大文件	426
17.5   内存映射文件与数据视图的相关性	427
17.6   设定内存映射文件的基地址	428
17.7   实现内存映射文件的具体方法	429
17.8   使用内存映射文件在进程之间共享
       数据	431
17.9   页文件支持的内存映射文件	431
17.10   稀疏提交的内存映射文件	438
第18章   堆栈	451
18.1   进程的默认堆栈	451
18.2   为什么要创建辅助堆栈	452
18.2.1   保护组件	452
18.2.2   更有效的内存管理	453
18.2.3   进行本地访问	453
18.2.4   减少线程同步的开销	453
18.2.5   迅速释放堆栈	453
18.3   如何创建辅助堆栈	454
18.3.1   从堆栈中分配内存块	455
18.3.2   改变内存块的大小	456
18.3.3   了解内存块的大小	456
18.3.4   释放内存块	457
18.3.5   撤消堆栈	457
18.3.6   用C++程序来使用堆栈	457
18.4   其他堆栈函数	460
第四部分   动态链接库
第19章    DLL基础	463
19.1   DLL与进程的地址空间	464
19.2   DLL的总体运行情况	465
19.3   创建DLL模块	467
19.3.1   输出的真正含义是什么	469
19.3.2   创建用于非Visual C++工具
            的DLL	471
19.4   创建可执行模块	472
19.5   运行可执行模块	474
第20章   DLL的高级操作技术	477
20.1   DLL模块的显式加载和
          符号链接	477
20.1.1   显式加载DLL模块	478
20.1.2   显式卸载DLL模块	479
20.1.3   显式链接到一个输出符号	480
20.2   DLL的进入点函数	481
20.2.1   DLL_PROCESS_ATTACH通知	482
20.2.2   DLL_PROCESS_DETACH通知	483
20.2.3   DLL_THREAD_ATTACH通知	485
20.2.4   DLL_THREAD_DETACH通知	485
20.2.5   顺序调用DllMain	486
20.2.6   DllMain与C/C++运行期库	488
20.3   延迟加载DLL	489
20.4   函数转发器	499
20.5   已知的DLL	499
20.6   DLL转移	500
20.7   改变模块的位置	501
20.8   绑定模块	506
第21章   线程本地存储器	509
21.1   动态TLS	509
21.2   静态TLS	513
第22章   插入DLL和挂接API	515
22.1   插入DLL：一个例子	515
22.2   使用注册表来插入DLL	517
22.3   使用Windows挂钩来插入DLL	518
22.4   使用远程线程来插入DLL	531
22.4.1   Inject Library 示例应用程序	534
22.4.2   Image Walk DLL	541
22.5   使用特洛伊DLL来插入DLL	544
22.6   将DLL作为调试程序来插入	544
22.7   用Windows 98上的内存映射文件
          插入代码	544
22.8   用CreateProcess插入代码	544
22.9   挂接API的一个示例	545
22.9.1   通过改写代码来挂接API	546
22.9.2   通过操作模块的输入节来挂接API	546
22.9.3   LastMsgBoxInfo示例应用程序	549
第五部分   结构化异常处理
第23章   结束处理程序	565
23.1   通过例子理解结束处理程序	566
23.2   Funcenstein1	566
23.3   Funcenstein2	566
23.4   Funcenstein3	568
23.5   Funcfurter1	568
23.6   突击测验：FuncaDoodleDoo	569
23.7   Funcenstein4	570
23.8   Funcarama1	571
23.9   Funcarama2	572
23.10   Funcarama3	572
23.11   Funcarama4：最终的边界	573
23.12   关于finally块的说明	574
23.13   Funcfurter2	575
23.14   SEH结束处理示例程序	576
第24章   异常处理程序和软件异常	578
24.1   通过例子理解异常过滤器和异常处理
       程序	578
24.1.1   Funcmeister1	578
24.1.2   Funcmeister2	579
24.2   EXCEPTION_EXECUTE_HANDLER	580
24.2.1   一些有用的例子	581
24.2.2   全局展开	583
24.2.3   暂停全局展开	585
24.3   EXCEPTION_CONTINUE_
          EXECUTION	586
24.4   EXCEPTION_CONTINUE_
          SEARCH	588
24.5   Get Exception Code 	589
24.6   Get Exception Information	592
24.7   软件异常	595
第25章   未处理异常和C++异常	598
25.1   即时调试	600
25.2   关闭异常消息框	601
25.2.1   强制进程终止运行	601
25.2.2   包装一个线程函数	601
25.2.3   包装所有的线程函数	601
25.2.4   自动调用调试程序	602
25.3  程序员自己调用UnhandledException
       Filter	602
25.4   UnhandledExceptionFilter函数的一些
       细节	603
25.5    异常与调试程序	604
25.6   C++异常与结构性异常的对比	618
第六部分   窗      口
第26章   窗口消息	623
26.1   线程的消息队列	623
26.2   将消息发送到线程的消息队列中	625
26.3    向窗口发送消息	626
26.4    唤醒一个线程	630
26.4.1   队列状态标志	630
26.4.2   从线程的队列中提取消息的
             算法	631
26.4.3   利用内核对象或队列状态标
             志唤醒线程	634
26.5   通过消息发送数据	636
26.6   Windows如何处理ANSI／Unicode
       字符和字符串	642
第27章   硬件输入模型和局部输入状态	645
27.1   原始输入线程	645
27.2   局部输入状态	646
27.2.1   键盘输入与焦点	647
27.2.2   鼠标光标管理	649
27.3   将虚拟输入队列同局部输入状态挂接
       在一起	651
27.3.1   LISLab 示例程序	652
27.3.2   LISWatch 示例程序	666
第七部分   附      录
附录A   建立环境	675
附录B   消息分流器、子控件宏和API宏	686
